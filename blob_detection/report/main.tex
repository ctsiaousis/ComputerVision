\documentclass[11pt]{scrartcl} % Font size

\input{structure.tex} % Include the file specifying the document structure and custom commands
\input{matlab.tex}

\usepackage{fontspec}
\setmainfont{Tinos Nerd Font} %nice font for english and greek

\begin{document}

\begin{titlepage}
    \centering
    \includegraphics[width=0.9\textwidth]{logo_tuc.png}\par\vspace{1cm}
    \normalfont\normalsize
    \textsc{\textcolor[rgb]{0.66, 0.09, 0.19}{Ηλεκτρολόγων Μηχανικών και Μηχανικών Υπολογιστών}}\\ % Your university, school and/or department name(s)
    \vspace{25pt} % Whitespace
    %\textcolor[rgb]{0.66, 0.09, 0.19}{\rule{\linewidth}{0.5pt}}
    \rule{\linewidth}{0.5pt}\\ % Thin top horizontal rule
    \vspace{20pt} % Whitespace
    {\Huge Μηχανική Όραση}\\ % The assignment title

    {\huge Αναφορά Δεύτερου Project}\\ % The assignment title
    \vspace{12pt} % Whitespace
    \rule{\linewidth}{2pt}\\ % Thick bottom horizontal rule
    \vspace{12pt} % Whitespace
    \vspace{2cm}

    {\LARGE{Τσιαούσης Χρήστος \hfill Μητσάκης Χαράλαμπος}
        \par
        \texttt{2016030017 \hfill 2006030075}
        \par
    }

    \vfill
    Διδάσκουσα

    Ε. Δούτση

    \vfill

% Bottom of the page
    {\large \today\par}
\end{titlepage}

\newpage



\section{Εισαγωγή}
Σκοπός της εργασίας ήταν η εύρεση αναγνωριστικών σημείων σε μία εικόνα χρησιμοποιώντας Λαπλασιανές πυραμίδες.
Η γενική ιδέα είναι πως καθώς γίνεται όλο και περισσότερο blur στην εικόνα, τα πιο ισχυρά feature παραμένουν.
Έτσι, συγκρίνοντας τις διαφοροποιήσεις κάποιου πίξελ με τα γειτονικά του στο χωρικό πεδίο, αλλά και στα γειτονικά
επίπεδα, μπορεί κανείς να αποφανθεί για την σημαντικότητά του. Τέλος, υλοποιήσαμε ενδεικτικά και ένα console
application σε \texttt{C++} που χρησιμοποιεί την \texttt{OpenCV4} και τρέχει τον αλγόριθμο \texttt{SURF} ο οποίος,
όπως θα δούμε παρακάτω, βγάζει παρόμοια points αλλά τρέχει πολύ πιο γρήγορα. Αυτό οφείλεται σε α) διαφορές στον αλγόριθμο,
β) βελτιστοποιήσεις στην υλοποίηση και γ) διαφορετική γλώσσα προγραμματισμού.


\section{Υλοποίηση}
Αν και η εκφώνηση περιείχε σημεία που εστίαζουν στην απόδοση, φάνηκε να έχουμε αρκετή ελευθερία κι έτσι επιλέξαμε
να φτάσουμε όσο πιο κοντά μπορούμε στο paper του Lowe. Έγινε μεγάλη προσπάθεια κατανόησης των μαθηματικών και \textbf{δεν}
έγινε χρήση εξωτερικών συναρτήσεων για την βασική λειτουργικότητα του αλγορίθμου.

\subsection{Δημιουργία φίλτρων και scale-space}

Απο το paper του Lowe γνωρίζουμε ότι το scale-space μπορεί να υπολογιστεί με συνέλιξη της εικόνας με τη διαφορά δύο gaussian φίλτρων ως εξής:

\[D(x,y,\sigma) = (G(x,y,k\sigma) − G(x,y,\sigma)) * I(x,y)\]

Όμως η διαφορά δύο gaussian φίλτρων μπορεί να προσεγγυστεί απο το laplacian of gaussian ως εξής:

\[G(x,y,k\sigma) − G(x,y,\sigma) \approx (k−1)\sigma^2 \nabla^2 G\]

Άρα:

\[D(x,y,\sigma) = ((k−1)\sigma^2 \nabla^2 G) * I(x,y)\]

Επομένως δημιουργούμε φίλτρα με περιττές διαστάσεις ως εξής:

\begin{verbatim}
for i = 1:log_scales_per_octave
  k_power = i-1;
  sigma_prime = k^k_power * sigma;
  log_filters{i} = (k - 1) * sigma_prime^2 * ...
    fspecial('log', floor(4*sigma_prime) * 2 + 1, sigma_prime);
end
\end{verbatim}

Επιλέξαμε περιττές διαστάσεις ώστε να έχουμε κεντρικό pixel και αυτό να συμπίπτει με το κέντρο της laplacian of gaussian καμπάνας.

\begin{figure}[H]
  \centerline{\includegraphics[width=24cm,trim={0 7cm 0 7cm},clip]{../output/filters.jpg}}
  \caption{Τα φίλτρα για την LoG πυραμίδα.}
\end{figure}

Αντί να δημιουργούμε φίλτρα για όλα τα scales χωρίζουμε το scale-space σε οκτάβες.

Η πρώτη εικόνα κάθε οκτάβας υπολογίζεται με υποδειγματοληψία της προηγούμενης οκτάβας στο $1/2$ του μεγέθους, εκτός απο την πρώτη οκτάβα που δημιουργείται με διπλασιασμό της αρχικής εικόνας με linear interpolation.

Κάθε οκτάβα αντιστοιχεί σε διπλασιασμό του $\sigma$, αλλα είναι πιο αποδοτικό, αντί να συνεχίζουμε να αυξάνουμε το $\sigma$, να κάνουμε downsample την εικόνα και να επαναχρησιμοποιούμε τα φίλτρα.

Έστω $s$ ο αριθμός των scales ανα οκτάβα στα οποία κάνουμε αναζήτηση extrema.
Κάθε οκτάβα περιέχει $s+2$ εικόνες. Γιαυτό δημιουργούμε $s+2$ φίλτρα τα οποία επαναχρησιμοποιούμε σε κάθε οκτάβα.
Οι 2 επιπλέον εικόνες υπάρχουν για να μπορέσουμε να κάνουμε αναζήτηση των extrema σε $s$ εικόνες γιατί για την αναζήτηση χρειαζόμαστε το επόμενο και το προηγούμενο scale όπως εξηγούμε παρακάτω (Εύρεση extrema).

Το $k$ υπολογίζεται απο το $s$ ως εξής: $k = 2^{1/s}$ γιατί κάθε οκτάβα αντιστοιχεί σε διπλασιασμό του $\sigma$ και η οκτάβα χωρίζεται σε $s$ διαστήματα.

Επιλέξαμε τις τιμές $\sigma = 1.6$, $k = 2^{1/3}$, $s = 3$ που είναι οι προτεινόμενες τιμές απο τον Lowe.
Επίσης επιλέξαμε $3$ οκτάβες, άρα έχουμε $n = 3 \cdot 5 = 15$ επίπεδα στα οποία κάναμε αναζήτηση extrema.

Το scale-space αποθηκεύεται σε ένα cell array με διαστάσεις $num\_of\_octaves \times (s+2)$ και κάθε στοιχείο του cell array περιέχει μια εικόνα.
\begin{verbatim}
scale_space = cell(num_of_octaves, s+2);
\end{verbatim}

\subsection{Εύρεση extrema}

Για να βρούμε τα τοπικά maxima και minima του scale-space (υποψήφια keypoints) συγκρίνουμε κάθε σημείο του scale-space
με τα 26 γειτονικά του (8 απο το ίδιο scale + 9 απο το κατώτερο + 9 απο το ανώτερο scale).

Αρχικά, για λόγους speedup, γίνεται σύγκριση μόνο με τους γείτονες του ίδιου επιπέδου, κι αν δεν είναι ο μεγαλύτερος ή ο
μικρότερος, ο αλγόριθμος συνεχίζει αναζητόντας το επόμενο pixel \textit{(x,y)} του επιπέδου. Αλλιώς συγκρίνει και με τους
γείτονες των γειτονικών επιπέδον κι αν είναι extrema τότε υπολογίζει τον \textbf{Hessian matrix}, όπως αυτός ορίζεται στο
\textit{sextion 3.3} του Lowe. Το Keypoint θα απορριφθεί αν ισχύει η σχέση (για $r = 10$):
\[\frac{Tr(H)^2}{Det(H)} >= \frac{(r+1)^2}{r}\]

Τέλος, αν η απόλυτη τιμή του \texttt{sample\_point} είναι \textbf{μεγαλύτερη} του \textbf{threshold} \textit{(Lowe: Algorithm 8)},
τότε το σημείο θεωρείται extrema και εισάγεται στα διανύσματα των x, y που θα χρησιμοποιηθούν για την αναπαράσταση των KeyPoints.
Η ακτίνα για τον κύκλο του κάθε σημείου υπολογίζεται από την σχέση $radius_{point} = scale_{point}\cdot octave_{point}$.
\subsection{Απεικόνιση}

Με την χρήση μίας boolean μεταβλητής μπορούμε να ελέγξουμε αν θα κάνουμε visualize τα φίλτρα και το scale\_space κι αυτό επιρρεάζει
ελφρώς τον χρόνο εκτέλεσης. Ενδεικτικά, ένα scale space που παράχθηκε από την εικόνα \texttt{fishes.jpg} και με παραμέτρους που θα
συζητηθούν στο επόμενο section, είναι το εξής:

\begin{figure}[H]
  \centerline{\includegraphics[width=20cm,clip]{../output/fishes_scales.jpg}}
  \caption{Scale Space της εικόνας fishes.jpg.}
\end{figure}

\section{Αποτελέσματα}

\subsection{fishes.jpg}
\begin{figure}[H]
  \centerline{\includegraphics[width=20cm,trim={0 5cm 0 5cm},clip]{../output/fishes.jpg}}
  \caption{}
\end{figure}

\subsection{sunflowers.jpg}
\begin{figure}[H]
  \centerline{\includegraphics[width=20cm,trim={0 3cm 0 3cm},clip]{../output/sunflowers.jpg}}
  \caption{}
\end{figure}

\subsection{otter.jpg}
\begin{figure}[H]
  \centerline{\includegraphics[width=20cm,trim={0 5cm 0 5cm},clip]{../output/otter.jpg}}
  \caption{}
\end{figure}

\subsection{plumeria.jpg}
\begin{figure}[H]
  \centerline{\includegraphics[width=24cm,trim={0 6cm 0 6cm},clip]{../output/plumeria.jpg}}
  \caption{}
\end{figure}

\section{Συμπεράσματα}

\end{document}
